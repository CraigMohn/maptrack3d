% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/draw3dMap.R
\name{draw3dMap}
\alias{draw3dMap}
\title{render a 3-D map from elevation and shapefile data and 
   add a set of paths to the plot}
\usage{
draw3dMap(paths = NULL, mapWindow = NULL, USStatevec = NULL,
  CAProvincevec = NULL, USParkvec = NULL, parkDir = NULL,
  worldCountryvec = NULL, cropbox = NULL, mapbuffer = 0,
  mapmergebuffer = 0, rectangularMap = TRUE, elevDataSource = "SRTM",
  mapDataDir = NULL, resstr = "_1arc_v3_bil",
  rasterFileSetNames = NULL, featureDataSource = "none",
  shapefileDir = NULL, writeShapefiles = TRUE, year = 2017,
  includeAllRoads = FALSE, zeroBufferTowns = FALSE,
  zeroBufferWater = FALSE, useImageRaster = FALSE,
  writeElevFile = FALSE, writeFeatureFile = FALSE,
  writeImageFile = FALSE, imageFilename = NULL, rasterDir = NULL,
  rasterFileSetWriteName = NULL, drawRGL = TRUE, res3dplot = 2500,
  drawProj4 = NULL, maxElev = 3000, minElev = 0, vScale = 1.5,
  seaLevel = NA, simpleSeaLevel = FALSE, townLevel = 3,
  roadLevel = 4, waterALevel = 4, waterLLevel = 5,
  rglColorScheme = "default", mapColorDepth = 16,
  rglNAcolor = "Blue", rglNegcolor = "Red", citycolor = "SlateGray",
  watercolor = "Blue", roadcolor = "Black", glaciercolor = "White",
  rglShininess = 0.02, rglSpecular = "black", rglDiffuse = "white",
  rglAmbient = "white", rglEmission = "black", rglSmooth = TRUE,
  rglAlpha = 1, rglAntiAlias = TRUE, rglTheta = 0, rglPhi = 15,
  trackColor = "Magenta", trackCurve = FALSE, trackWidth = 0,
  trackCurveElevFromRaster = FALSE, trackCurveHeight = 10,
  saveRGL = FALSE, mapoutputdir = NULL, outputName = NULL,
  gapTooLong = 100,
  workProj4 = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0",
  maxrastercells = 2.5e+08, maxRasterize = 5e+05, polySimplify = 0,
  polyMethod = "vis", polyWeighting = 0.85, polySnapInt = 1e-04,
  silent = FALSE, noisy = FALSE)
}
\arguments{
\item{paths}{a set of segments which are contained in a 
data frame or tibble containing at least: lon, lat, (these may also have
the names "position_lon.dd" and "position_lat.dd") and are both 
numeric with decimal degrees, and segment(numeric) to identify 
different paths or segments on a path.  If trackCurveElevFromRaster
is FALSE, the data frame must include a column named altitude.m which 
contains the elevation recorded by the GPS.  The optional character
variable color specifies the color on track segments}

\item{mapWindow}{a vector of 4 numbers which describe the region drawn.
The format is c(lon_min, lon_max, lat_min, lat_max)}

\item{USStatevec}{vector of standard 2-letter abbreviations of US states, or
pre-defined regional aggregations of states for use in defining map or
finding features to include in the map}

\item{CAProvincevec}{vector of standard 2-letter abbreviations of Canadian
provinvces states, or pre-defined regional aggregations of states for 
use in defining map or finding features to include in the map}

\item{USParkvec}{vector of US National Park names.  If specified, map
will include the specified Parks but not the listed US states}

\item{parkDir}{string location of downloaded US Park boundary shapefiles 
downloaded from, for example, https://irma.nps.gov/DataStore/}

\item{worldCountryvec}{vector of 3-letter ISO country abbreviations}

\item{cropbox}{vector of 4 numbers for cropping the map defined above
The format is c(lon_min, lon_max, lat_min, lat_max).}

\item{mapbuffer}{numeric value to expand defined map}

\item{mapmergebuffer}{numeric value to expand components (states, provinces,
countries) of the map defined before merging, to eliminate gaps from minor
boundary inconsistencies}

\item{rectangularMap}{logical, draw the entire rectangle enclosing the specified
map area, as long as all relevant state/province rasters have been loaded}

\item{elevDataSource}{character, "SRTM" to load data from saved SRTM data, 
"Raster" to load saved raster files}

\item{mapDataDir}{character, directory where zipped SRTM data files reside}

\item{resstr}{character, suffix on SRTM data files after lon/lat info}

\item{rasterFileSetNames}{vector of names of saved raster data files}

\item{featureDataSource}{character, "Shapefiles" to load saved shapefiles, 
"TIGER" to fetch TIGER data for US states, "Raster" to load saved raster data
from directory specified , "none" to show none}

\item{shapefileDir}{character location to load/save shapefiles}

\item{writeShapefiles}{logical, write/overwrite shapefiles if TIGER data is used}

\item{year}{numeric year to use in calls for map boundaries/features}

\item{includeAllRoads}{logical, include all roads in shapefile, not just highways}

\item{zeroBufferTowns}{logical, use zero buffer trick to repair town polygon shapefile}

\item{zeroBufferWater}{logical, use zero buffer trick to repair water polygon shapefile}

\item{useImageRaster}{logical, use the image raster from saved openStreetmap 
colrings of the map surface}

\item{writeElevFile}{logical, save the elevation raster files}

\item{writeFeatureFile}{logical, save the feature data raster files}

\item{writeImageFile}{logical, save the "bing","apple-iphoto","stamen-terrain"
images specified in rglColorScheme as a raster file}

\item{imageFilename}{name of raster or tiff file containing map background}

\item{rasterDir}{character location to load and save raster files}

\item{rasterFileSetWriteName}{name to use for the raster fileset written}

\item{drawRGL}{logical, open a window with the interactive 3D map}

\item{res3dplot}{numeric, used to scale resolution, the maximum size the square root
of the output height times width.  aggregation done in integer multiples.}

\item{drawProj4}{string containing the projection to use in drawing the map,
"UTM" (zone based on center of map),"Lambert","Albers", or any Proj4 string}

\item{maxElev}{numeric, all elevations greater than this are colored at the
high end of the palette}

\item{minElev}{numeric, all elevations less than this are colored at the
low end of the palette}

\item{vScale}{numeric vertical scale parameter, try bigger values for smaller areas}

\item{seaLevel}{numeric, fill water to this level if specified}

\item{simpleSeaLevel}{logical, flood if below seaLevel even if not connected to edge}

\item{townLevel}{numeric, display towns ranked this number or higher: 
3=all towns     5=larger towns (in US >50k)}

\item{roadLevel}{numeric, display roads ranked this number or higher:
2=Service Drive, Bike Path, etc      3=Local Street
4=Secondary Hwy                      5=Primary Hwy/Transit}

\item{waterALevel}{numeric, display areal water ranked this number or higher:
2=res/treatmentpond/pit/quarry       3=lake/pond/swamp/stream
4=class 2 or 3 bigger than 1k ha     5=named lake/pond/swamp/stream
6=large lake/pond/swamp/stream       7=Ocean/Bay/Est/Sound
8=glacier}

\item{waterLLevel}{numeric, display linear water ranked this number or higher:
2=canal/ditch                        3=braided stream
4=stream/river                       5=named stream/river
6=named stream/river containing the string "RIV"}

\item{rglColorScheme}{name of color scheme from 
c("default","beach","viridis","plasma","terrain","oleron","snow","oslo",
  "desert","lajolla","niccoli","bright",
  "bing","maptoolkit-topo","nps","apple-iphoto")}

\item{mapColorDepth}{number of bits per color channel in map image}

\item{rglNAcolor}{character, color used to display NA elevations}

\item{rglNegcolor}{character, color used to display elevations below sea level}

\item{citycolor}{character, color used to display cities}

\item{watercolor}{character, color used to display water,}

\item{roadcolor}{character, color used to display roads}

\item{glaciercolor}{character, color used to display glaciers}

\item{rglShininess}{number controlling surface shininess in rgl rendering}

\item{rglSpecular}{character, light color for specular light}

\item{rglDiffuse}{character, light color for diffuse light}

\item{rglAmbient}{character, light color for ambient light}

\item{rglEmission}{character, color of emitted light}

\item{rglSmooth}{logical, use Gouraud shading if TRUE}

\item{rglAlpha}{numeric alpha value for surface}

\item{rglAntiAlias}{logical, antialias points and lines when drawing surface}

\item{rglTheta}{numeric coordinate for light source}

\item{rglPhi}{numeric coordinate for light source}

\item{trackColor}{character, name of color used to draw tracks}

\item{trackCurve}{logical, draw the tracks as curves above the surface}

\item{trackWidth}{integer, add to minimal line width}

\item{trackCurveElevFromRaster}{logical, get curve elevations from elevation raster}

\item{trackCurveHeight}{numeric, distance above surface to draw curve (meters)}

\item{saveRGL}{logical, save the map to an html file}

\item{mapoutputdir}{character location for saved html map file}

\item{outputName}{name of saved html map}

\item{gapTooLong}{numeric (meters). Sequential track observations which are
farther aopart than this are not connected}

\item{workProj4}{coordinate reference projection string}

\item{maxrastercells}{maximum number of cells in each written raster}

\item{maxRasterize}{number of number of items for calls to velox$rasterize}

\item{polySimplify}{numeric, amount of polygon simplification, see help
for rmapshaper::ms_simplify}

\item{polyMethod}{simplification method either "vis" or "dp"}

\item{polyWeighting}{see help for rmapshaper::ms_simplify}

\item{polySnapInt}{see help for rmapshaper::ms_simplify}

\item{silent}{logical, suppress most output}

\item{noisy}{logical, more output to track progress}
}
\description{
\code{draw3dMap} draw 3D map from elevation and feature data,
   and add a set of paths to the plot
}
\details{
Create a map displaying the tracks specified.  Tracks may be drawn in one
   specified color, with each separate track drawn in a different color from
   a specified palette, or as a series of closely spaced dots (which may
   be prodded into appearing as a line through judicious choice of point
   size and alpha) with the color varying based on speed and the chosen
   palette
}
\examples{
\dontrun{
##  draw a rectangular region from local SRTM data
##    to download the data, start at https://earthexplorer.usgs.gov/ ,
##    create a free account and order the data you need
##    put it into mapDataDir
mapWindow <- c(23.3,27.4,34.7,36.0)  # Crete
draw3dMap(mapWindow=mapWindow,
          mapDataDir="c:/bda/Europe 1s",
          vScale=1.6,
          rglColorScheme="bing",
          drawProj4="UTM", 
          saveRGL=TRUE,mapoutputdir=mapoutputdir,
          outputName="Crete")

##  draw US Yosemite National Park from local SRTM data
draw3dMap(USParkvec="YOSE",USStatevec="CA",
          parkDir=parkDir,mapbuffer=10000,
          mapDataDir=mapDataDir,
          shapefileDir=shapefileDir,
          featureDataSource="shapefiles",
          townLevel=3,roadLevel=2,waterALevel=4,waterLLevel=5,
          vScale=1.5,
          rglColorScheme="terrain",
          drawProj4="UTM",
          saveRGL=TRUE,mapoutputdir=mapoutputdir,
          outputName="Yosemite")
##  draw US Yosemite National Park from CGIAR hosted SRTM data
draw3dMap(USParkvec="YOSE",USStatevec="CA",
          parkDir=parkDir,mapbuffer=10000,
          vScale=1.5,
          rglColorScheme="bing",
          drawProj4="UTM", 
          saveRGL=TRUE,mapoutputdir=mapoutputdir,
          outputName="Yosemite CGIAR bing")
##  draw US Yosemite National Park from CGIAR hosted SRTM data and TIGER data
draw3dMap(USParkvec="YOSE",USStatevec="CA",
          parkDir=parkDir,mapbuffer=10000,
          shapefileDir=shapefileDir,
          featureDataSource="shapefiles",
          townLevel=3,roadLevel=2,waterALevel=4,waterLLevel=5,
          vScale=1.5,
          rglColorScheme="bing",
          drawProj4="UTM",
          saveRGL=TRUE,mapoutputdir=mapoutputdir,
          outputName="Yosemite CGIAR bing TIGER")
## draw mainland Portugal from CGIAR hosted data
draw3dMap(worldCountryvec="PRT",
          cropbox=c(-10, 10, 36, 43), # remove islands
          mapbuffer=100, # expand boundary to speed masking
          vScale=1.4,    # increase scale with bing coloring
          rglColorScheme="bing",
          drawProj4="Albers", 
          saveRGL=TRUE,mapoutputdir=mapoutputdir,
          outputName="Portugal Albers bing")
}

}
